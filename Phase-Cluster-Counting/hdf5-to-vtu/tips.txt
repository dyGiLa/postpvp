Excellent question ‚Äî you've identified a key limitation of using XDMF with HDF5 in ParaView:

    üîí XDMF allows ParaView to visualize parallel HDF5 data,
    ‚ùå but the data doesn't get wrapped as vtkDataArray / numpy in Python Programmable Filter,
    so you can't access it from Python as NumPy arrays (e.g., in a programmable filter or script).
    
    Why This Happens

When you open HDF5 through XDMF in ParaView:

    Data is loaded lazily through the XDMF plugin, not through VTK's memory-backed pipeline.

    So fields like inputs[0].PointData["velocity"] don't return NumPy-wrapped arrays ‚Äî they‚Äôre inaccessible or unusable in Python filters.
    
Option 2: Manually convert the XDMF-HDF5 pipeline to VTK objects in Python

If you must use the XDMF path, you can try "forcing" the conversion using ParaView‚Äôs built-in Python capabilities:
In a Programmable Filter:

from paraview.vtk.util import numpy_support
import numpy as np

input0 = inputs[0]
velocity_vtk = input0.PointData.GetArray("velocity")

if velocity_vtk is None:
    raise RuntimeError("Velocity field not loaded or accessible.")

velocity_np = numpy_support.vtk_to_numpy(velocity_vtk)

But this may fail if the array isn‚Äôt memory-resident ‚Äî which often happens with XDMF.    



2. Generate .pvts Master File

The .pvts file references all the .vts pieces and their positions in the global grid.
üîß write_pvts.py

import xml.etree.ElementTree as ET

def write_pvts(pvts_path, pieces, spacing, data_arrays):
    dx, dy, dz = spacing

    vtkfile = ET.Element("VTKFile", type="PStructuredGrid", version="0.1", byte_order="LittleEndian")
    pgrid = ET.SubElement(vtkfile, "PStructuredGrid", WholeExtent="0 0 0 0 0 0")  # updated later

    # Point data fields
    point_data = ET.SubElement(pgrid, "PPointData")
    for name, ncomp in data_arrays.items():
        ET.SubElement(point_data, "PDataArray", type="Float32", Name=name, NumberOfComponents=str(ncomp), format="ascii")

    # Points (coordinates implicitly defined)
    ET.SubElement(pgrid, "PPoints").append(
        ET.Element("PDataArray", type="Float32", NumberOfComponents="3", format="ascii")
    )

    # Determine global extent
    global_extent = [float('inf'), -float('inf')] * 3
    for i, (filename, origin, dims) in enumerate(pieces):
        ox, oy, oz = origin
        ni, nj, nk = dims

        start_i = int(ox / dx)
        start_j = int(oy / dy)
        start_k = int(oz / dz)
        end_i = start_i + ni - 1
        end_j = start_j + nj - 1
        end_k = start_k + nk - 1

        global_extent[0] = min(global_extent[0], start_i)
        global_extent[1] = max(global_extent[1], end_i)
        global_extent[2] = min(global_extent[2], start_j)
        global_extent[3] = max(global_extent[3], end_j)
        global_extent[4] = min(global_extent[4], start_k)
        global_extent[5] = max(global_extent[5], end_k)

        piece_tag = ET.SubElement(pgrid, "Piece")
        piece_tag.set("Source", os.path.basename(filename))
        piece_tag.set("Extent", f"{start_i} {end_i} {start_j} {end_j} {start_k} {end_k}")

    # Set global extent
    pgrid.set("WholeExtent", " ".join(str(e) for e in global_extent))

    # Write XML
    tree = ET.ElementTree(vtkfile)
    tree.write(pvts_path, encoding="utf-8", xml_declaration=True)
    print(f"Saved {pvts_path}")

‚úÖ 3. Run the Full Conversion




What You Need to Do
1. Update hdf5_to_vts() to:

    Read ghost/values from your HDF5

    Add it as a special vtkGhostType array (uint8 array)

2. No change is needed to write_pvts() ‚Äî the .pvts file doesn't directly describe ghosting. The ghost markers are embedded in each .vts file.

import h5py
import pyvista as pv
import numpy as np
import os

def hdf5_to_vts(h5file, output_dir):
    with h5py.File(h5file, 'r') as f:
        # Grid metadata
        ni = f['dims/i'][()]
        nj = f['dims/j'][()]
        nk = f['dims/k'][()]
        dx = f['spacing/dx'][()]
        dy = f['spacing/dy'][()]
        dz = f['spacing/dz'][()]
        ox = f['origin/x'][()]
        oy = f['origin/y'][()]
        oz = f['origin/z'][()]

        # Structured grid
        grid = pv.UniformGrid()
        grid.dimensions = (ni, nj, nk)
        grid.spacing = (dx, dy, dz)
        grid.origin = (ox, oy, oz)

        # Field data
        for field_name in f['fields']:
            values = f[f'fields/{field_name}/values'][()]

            if values.ndim == 1:
                grid[field_name] = values.ravel(order='F')
            elif values.ndim == 2 and values.shape[1] == 3:
                grid[field_name] = values.reshape((ni * nj * nk, 3), order='F')
            else:
                print(f"Skipping field {field_name} with shape {values.shape}")

        # Ghost array (optional)
        if 'ghost/values' in f:
            ghost = f['ghost/values'][()].astype(np.uint8)
            ghost = ghost.ravel(order='F')  # Ensure same ordering
            grid.point_data["vtkGhostType"] = ghost
            print(f"Added ghost array with {np.count_nonzero(ghost)} ghosted points")

        # Save .vts
        basename = os.path.splitext(os.path.basename(h5file))[0]
        vts_path = os.path.join(output_dir, f"{basename}.vts")
        grid.save(vts_path)

        print(f"Saved {vts_path}")
        return vts_path, (ox, oy, oz), (ni, nj, nk)

